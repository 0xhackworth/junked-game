<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Junked: The Game of High-Stakes Yields</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script type="module">
        // Updated SDK versions to 12.4.0 for consistency with user's snippet
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, runTransaction } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";

        // --- GLOBAL VARIABLES AND CONSTANTS ---

        let db;
        let auth;
        let userId;
        let gameId;
        const GAME_SESSION_ID = 'game-session-1'; // Fixed ID for shared session
        const APP_ID = 'junked-game'; // Using the projectId as a stable App ID placeholder
        const DB_PATH = (id) => `artifacts/${APP_ID}/public/data/junked_games/${id}`;

        // Game Constants based on the final rulebook
        const GAME_CONSTANTS = {
            // Currencies and Values (in k)
            STARTING_CAPITAL: 2000,
            MANDATORY_PURCHASE: 1050,
            STARTING_CASH: 950,
            SECURED_ASSET_VALUE: 250,
            MAX_FACE_VALUE: 500,
            T_BILL_INCREMENT: 100,
            T_BILL_YIELD_RATE: 0.15,

            // Actions Costs (in k)
            COST_RESEARCH: 50,
            COST_INSURANCE: 75,
            COST_SABOTAGE: 75,
            COST_ASSET_MAINTENANCE: 75,
            
            // Tender Offer Values (in k)
            BRIBE_AMOUNT: 200,
            RICO_FINE: 300,
            TARGET_COMPENSATION: 150,
            LIQUIDATION_BONUS: 150,
            TARGET_RESTRICTION_ROUNDS: 3,

            // Tiers and Ratings
            TIERS: {
                T1: { yield: 15, rating: 'BB', name: 'Safe', color: 'bg-green-600' },
                T2: { yield: 25, rating: 'B', name: 'Standard', color: 'bg-yellow-600' },
                T3: { yield: 40, rating: 'CCC', name: 'Junk', color: 'bg-red-600' },
            },
            RATING_PRICES: {
                'IG': { mult: 1.10, sell: 550, buy: 400, label: 'Investment Grade', color: 'text-blue-500' },
                'BB': { mult: 0.85, sell: 425, buy: 400, label: 'Speculative Grade', color: 'text-green-500' },
                'B': { mult: 0.70, sell: 350, buy: 350, label: 'High Yield', color: 'text-yellow-500' },
                'CCC': { mult: 0.55, sell: 275, buy: 200, label: 'Very High Risk', color: 'text-orange-500' },
                'CC': { mult: 0.40, sell: 200, buy: 200, label: 'Near Default', color: 'text-red-500' },
                'C': { mult: 0.25, sell: 125, buy: 200, label: 'Extremely Vulnerable', color: 'text-red-700' },
                'D': { mult: 0.00, sell: 0, buy: 0, label: 'Defaulted', color: 'text-gray-500' },
            },
            RATING_ORDER: ['IG', 'BB', 'B', 'CCC', 'CC', 'C', 'D'],
            MAX_ROUNDS: 10
        };

        // --- UTILITY FUNCTIONS ---

        const shuffle = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        };

        const getNextRating = (current) => {
            const index = GAME_CONSTANTS.RATING_ORDER.indexOf(current);
            return index > 0 ? GAME_CONSTANTS.RATING_ORDER[index - 1] : current;
        };

        const getPrevRating = (current, steps = 1) => {
            const index = GAME_CONSTANTS.RATING_ORDER.indexOf(current);
            const newIndex = Math.min(GAME_CONSTANTS.RATING_ORDER.length - 1, index + steps);
            return GAME_CONSTANTS.RATING_ORDER[newIndex];
        };

        const getRatingColor = (rating) => GAME_CONSTANTS.RATING_PRICES[rating]?.color || 'text-gray-400';

        const getRatingLabel = (rating) => GAME_CONSTANTS.RATING_PRICES[rating]?.label || 'Unknown';
        
        const getBuyPrice = (rating) => GAME_CONSTANTS.RATING_PRICES[rating]?.buy || 0;

        const getSellPrice = (rating) => GAME_CONSTANTS.RATING_PRICES[rating]?.sell || 0;
        
        // --- GAME DATA INITIALIZATION ---

        const createBondDeck = () => {
            let deck = [];
            const industries = ['Tech', 'Oil', 'Retail', 'Real Estate', 'Aviation', 'Pharma', 'Defense', 'Media', 'Auto', 'Energy'];
            const names = ['MegaCorp', 'Apex Holdings', 'Crimson Industries', 'Quantum Systems', 'Starlight LTD', 'Midnight Finance', 'Zephyr Dynamics'];

            let id = 1;
            ['T1', 'T2', 'T3'].forEach(tierKey => {
                const tier = GAME_CONSTANTS.TIERS[tierKey];
                for (let i = 0; i < 7; i++) {
                    const industry = industries[Math.floor(Math.random() * industries.length)];
                    const name = names[Math.floor(Math.random() * names.length)];
                    deck.push({
                        id: id++,
                        name: `${name} (${tier.name} - ${industry})`,
                        tier: tierKey,
                        industry: industry,
                        yield: tier.yield,
                        rating: tier.rating,
                        faceValue: GAME_CONSTANTS.MAX_FACE_VALUE,
                        ownerId: null,
                    });
                }
            });
            return shuffle(deck.slice(0, 20)); // Ensure exactly 20 cards
        };

        const createMarketDeck = () => {
            const events = [
                { type: 'BOOM', desc: 'Tech Sector Boom! All Tech bonds move up one rating. Max IG.', industry: 'Tech', effect: (game) => massRatingChange(game, 'Tech', getNextRating) },
                { type: 'BUST', desc: 'Oil Price Collapse. All Oil bonds move down one rating.', industry: 'Oil', effect: (game) => massRatingChange(game, 'Oil', getPrevRating) },
                { type: 'RATE_HIKE', desc: 'The Fed raises rates. All bonds move down one rating.', effect: (game) => massRatingChange(game, null, getPrevRating) },
                { type: 'LITIGATION', desc: 'Retail Lawsuits: All Retail bonds face a default roll (1-2 on D6).', industry: 'Retail', roll: true },
                { type: 'SUCCESS', desc: 'Economic Miracle! All bonds move up one rating. Max IG.', effect: (game) => massRatingChange(game, null, getNextRating) },
                { type: 'DEFAULT_TEST', desc: 'Energy Sector stress test. All Energy bonds roll for default (1-3 on D6).', industry: 'Energy', roll: true },
                { type: 'DEFAULT_TEST', desc: 'Auto Industry faces parts shortage. All Auto bonds roll for default (1-3 on D6).', industry: 'Auto', roll: true },
                { type: 'NO_EVENT', desc: 'Quiet Trading Day. Nothing major changes.' },
                { type: 'INDUSTRY_UP', desc: 'Pharma Sector breakthrough! All Pharma bonds move up two ratings. Max IG.', industry: 'Pharma', effect: (game) => massRatingChange(game, 'Pharma', (r) => getNextRating(getNextRating(r))) },
                { type: 'INDUSTRY_DOWN', desc: 'Aviation Regulation hits hard. All Aviation bonds move down two ratings.', industry: 'Aviation', effect: (game) => massRatingChange(game, 'Aviation', (r) => getPrevRating(getPrevRating(r))) },
            ];
            // Repeat to pad the deck
            let deck = [];
            for(let i = 0; i < 4; i++) { deck = deck.concat(events); }
            return shuffle(deck.slice(0, 40)); // Ensure a reasonable size
        };

        const createMalfeasanceDeck = () => {
            return shuffle([
                { type: 'MALFEASANCE', desc: 'Whistleblower Scandal. Target bond drops three ratings.', downgrade: 3, tender: true },
                { type: 'MALFEASANCE', desc: 'Key Executive Quits. Target bond drops two ratings.', downgrade: 2, tender: true },
                { type: 'MALFEASANCE', desc: 'Insider Trading Fine. Target bond drops two ratings.', downgrade: 2, tender: true },
                { type: 'MALFEASANCE', desc: 'Regulatory Overreach. Target bond drops one rating.', downgrade: 1, tender: true },
                { type: 'BACKFIRE', desc: 'DUE DILIGENCE BACKFIRE. Colluders fined, Target compensated.', tender: true },
                { type: 'BACKFIRE', desc: 'DUE DILIGENCE BACKFIRE. Colluders fined, Target compensated.', tender: true },
                { type: 'SABOTAGE', desc: 'Public Relations Crisis. Target bond drops two ratings.', downgrade: 2, tender: false },
                { type: 'SABOTAGE', desc: 'Hostile Press Leak. Target bond drops two ratings.', downgrade: 2, tender: false },
                { type: 'SABOTAGE', desc: 'Targeted DDoS Attack. Target bond drops two ratings.', downgrade: 2, tender: false },
                { type: 'SABOTAGE', desc: 'Bad Quarterly Report. Target bond drops two ratings.', downgrade: 2, tender: false },
            ].slice(0, 10)); // Ensure 10 cards
        };
        
        // --- FIREBASE INITIALIZATION AND GAME STATE MANAGEMENT ---
        
        const initFirebase = async () => {
            try {
                // --- INJECTED FIREBASE CONFIGURATION (User provided) ---
                const firebaseConfig = {
                    apiKey: "AIzaSyCqMdhBWcXEfCw575HMHgsS2cRR64wBEBE",
                    authDomain: "junked-game.firebaseapp.com",
                    projectId: "junked-game",
                    storageBucket: "junked-game.firebasestorage.app",
                    messagingSenderId: "150414672185",
                    appId: "1:150414672185:web:5f48e37eacf96f0552e8e8"
                };
                // --- END OF INJECTED FIREBASE CONFIGURATION ---

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        gameId = GAME_SESSION_ID; // Using a fixed ID for a single shared session
                        console.log("Authenticated as:", userId);
                        
                        await ensurePlayerProfile(userId);
                        await initOrLoadGame(gameId);
                    }
                });

            } catch (error) {
                console.error("Firebase initialization error:", error);
                document.getElementById('game-log').innerHTML += `<p class="text-red-600">FATAL ERROR: Failed to initialize Firebase. ${error.message}</p>`;
            }
        };

        const ensurePlayerProfile = async (uid) => {
            const profileRef = doc(db, `artifacts/${APP_ID}/users/${uid}/junked_profile/data`);
            const profileSnap = await getDoc(profileRef);
            if (!profileSnap.exists()) {
                 await setDoc(profileRef, {
                    displayName: `Player ${Math.floor(Math.random() * 900) + 100}`,
                    userId: uid,
                    joinedAt: new Date(),
                 });
            }
        };

        const initOrLoadGame = async (id) => {
            const gameRef = doc(db, DB_PATH(id));
            let initialState = null; // Declare initialState here

            // Set up listener first (This will handle all subsequent UI updates)
            onSnapshot(gameRef, (doc) => {
                if (doc.exists()) {
                    updateUI(doc.data());
                }
            });


            try {
                await runTransaction(db, async (transaction) => {
                    const gameSnap = await transaction.get(gameRef);

                    if (!gameSnap.exists()) {
                        // --- 1. GAME CREATION ---
                        const bondDeck = createBondDeck();
                        const initialTrack = bondDeck.splice(0, 4);

                        const initialPlayers = {};
                        const playerName = `Player ${Math.floor(Math.random() * 900) + 100}`;
                        initialPlayers[userId] = {
                            cash: GAME_CONSTANTS.STARTING_CASH,
                            tBills: 0,
                            bonds: [],
                            insuranceContracts: 0,
                            securedAssets: 0,
                            actionsLeft: 0,
                            name: playerName,
                            id: userId,
                        };
                        
                        // Give starter bonds
                        for(let i = 0; i < 3; i++) {
                            const starterBond = {
                                id: `starter-${i + 1}-${userId}`,
                                name: `Starter Bond ${i + 1} (Tier 2 - Mixed)`,
                                tier: 'T2',
                                industry: 'Mixed',
                                yield: GAME_CONSTANTS.TIERS.T2.yield,
                                rating: 'B',
                                faceValue: GAME_CONSTANTS.MAX_FACE_VALUE,
                            };
                            initialPlayers[userId].bonds.push(starterBond);
                        }


                        initialState = { // Set initialState inside the transaction
                            round: 1,
                            phase: 1, // 1: Yield, 2: Shock, 3: Trading
                            status: 'SETUP',
                            currentPlayerIndex: 0,
                            playerOrder: [userId],
                            players: initialPlayers,
                            offeringsTrack: initialTrack,
                            companyDeck: bondDeck,
                            marketDeck: createMarketDeck(),
                            malfeasanceDeck: createMalfeasanceDeck(),
                            log: [{ time: new Date().toISOString(), message: `Game created by ${playerName}. Waiting for 3-4 players.` }],
                            currentMarketEvent: null,
                            tenderOffer: null, 
                        };
                        transaction.set(gameRef, initialState);
                        console.log("Game initialized and data set in transaction.");
                        
                    } else {
                        // --- 2. GAME EXISTENCE CHECK ---
                        initialState = gameSnap.data();
                        
                        // FIX: Check if current user is missing from player list
                        if (!initialState.players[userId]) {
                            // User not in game yet - add them to the state
                            const playerName = `Player ${Math.floor(Math.random() * 900) + 100}`;
                            
                            const newPlayerProfile = {
                                cash: GAME_CONSTANTS.STARTING_CASH,
                                tBills: 0,
                                bonds: [],
                                insuranceContracts: 0,
                                securedAssets: 0,
                                actionsLeft: 0,
                                name: playerName,
                                id: userId,
                            };
                            
                            // Give starter bonds
                            for(let i = 0; i < 3; i++) {
                                const starterBond = {
                                    id: `starter-${i + 1}-${userId}`,
                                    name: `Starter Bond ${i + 1} (Tier 2 - Mixed)`,
                                    tier: 'T2',
                                    industry: 'Mixed',
                                    yield: GAME_CONSTANTS.TIERS.T2.yield,
                                    rating: 'B',
                                    faceValue: GAME_CONSTANTS.MAX_FACE_VALUE,
                                };
                                newPlayerProfile.bonds.push(starterBond);
                            }

                            initialState.players[userId] = newPlayerProfile;

                            // Add to player order if in setup and not full
                            if(initialState.status === 'SETUP' && initialState.playerOrder.length < 4) {
                                initialState.playerOrder.push(userId);
                                transaction.update(gameRef, { 
                                    players: initialState.players,
                                    playerOrder: initialState.playerOrder,
                                    log: [...initialState.log, { time: new Date().toISOString(), message: `${playerName} joined the game (auto-added).` }]
                                });
                                console.log(`Updated player list with new user ${playerName}.`);
                            } else {
                                // If game is IN_PROGRESS or FULL, we still update the players map 
                                // to record their portfolio, but they won't join the playerOrder.
                                transaction.update(gameRef, { players: initialState.players });
                                console.log(`User ${playerName} added portfolio, but game is not accepting new players into playerOrder.`);
                            }
                        }
                    }
                });
                
                // CRITICAL FIX: Force immediate UI update after transaction. 
                // This ensures the UI is not 'Loading...' while waiting for the listener to fire.
                const finalSnap = await getDoc(gameRef);
                if (finalSnap.exists()) {
                    updateUI(finalSnap.data());
                }


            } catch (e) {
                console.error("Transaction failed: ", e);
            }
        };

        // --- GAME LOGIC FUNCTIONS ---

        const getPlayerNames = (game) => {
            return Object.values(game.players).map(p => ({
                id: p.id || Object.keys(game.players).find(key => game.players[key] === p) || p.userId,
                name: p.name,
                isCurrent: game.playerOrder[game.currentPlayerIndex] === (p.id || p.userId)
            }));
        };

        const getPlayerDisplayId = (id) => {
            // Simple placeholder for displaying user IDs
            return id.substring(0, 6) + '...';
        };

        const massRatingChange = (game, industry, changeFn, targetBonds = game.companyDeck.concat(Object.values(game.players).flatMap(p => p.bonds))) => {
            let log = [];
            
            const processBonds = (bonds, isPlayerBonds = false) => {
                bonds.forEach(bond => {
                    if (bond.rating === 'D') return;

                    if (!industry || bond.industry === industry || isPlayerBonds) {
                        const oldRating = bond.rating;
                        let newRating = changeFn(oldRating);
                        
                        // Max IG check for Market Events
                        if ((changeFn === getNextRating || changeFn === ((r) => getNextRating(getNextRating(r)))) && oldRating === 'BB' && !isPlayerBonds) {
                            newRating = 'IG';
                        }
     