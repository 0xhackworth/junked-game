<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Junked: The Game of High-Stakes Yields</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script type="module">
        // Updated SDK versions to 12.4.0 for consistency
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, runTransaction, deleteDoc } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";

        // --- GLOBAL VARIABLES AND CONSTANTS ---

        let db;
        let auth;
        let userId;
        let gameId;
        let currentGameState; // Holds the latest game state for UI functions
        const GAME_SESSION_ID = 'game-session-1'; // Fixed ID for shared session
        const APP_ID = 'junked-game'; // Using the projectId as a stable App ID placeholder
        const DB_PATH = (id) => `artifacts/${APP_ID}/public/data/junked_games/${id}`;

        // Game Constants based on the final rulebook
        const GAME_CONSTANTS = {
            // Currencies and Values (in k)
            STARTING_CAPITAL: 2000,
            MANDATORY_PURCHASE: 1050,
            STARTING_CASH: 950,
            SECURED_ASSET_VALUE: 250,
            MAX_FACE_VALUE: 500,
            T_BILL_INCREMENT: 100,
            T_BILL_YIELD_RATE: 0.15,

            // Actions Costs (in k)
            COST_RESEARCH: 50,
            COST_INSURANCE: 75,
            COST_SABOTAGE: 75,
            COST_ASSET_MAINTENANCE: 75,
            
            // Tender Offer Values (in k)
            BRIBE_AMOUNT: 200,
            RICO_FINE: 300,
            TARGET_COMPENSATION: 150,
            LIQUIDATION_BONUS: 150,
            TARGET_RESTRICTION_ROUNDS: 3,

            // Tiers and Ratings
            TIERS: {
                T1: { yield: 15, rating: 'BB', name: 'Safe', color: 'bg-green-600' },
                T2: { yield: 25, rating: 'B', name: 'Standard', color: 'bg-yellow-600' },
                T3: { yield: 40, rating: 'CCC', name: 'Junk', color: 'bg-red-600' },
            },
            RATING_PRICES: {
                'IG': { mult: 1.10, sell: 550, buy: 400, label: 'Investment Grade', color: 'text-blue-500' },
                'BB': { mult: 0.85, sell: 425, buy: 400, label: 'Speculative Grade', color: 'text-green-500' },
                'B': { mult: 0.70, sell: 350, buy: 350, label: 'High Yield', color: 'text-yellow-500' },
                'CCC': { mult: 0.55, sell: 275, buy: 200, label: 'Very High Risk', color: 'text-orange-500' },
                'CC': { mult: 0.40, sell: 200, buy: 200, label: 'Near Default', color: 'text-red-500' },
                'C': { mult: 0.25, sell: 125, buy: 200, label: 'Extremely Vulnerable', color: 'text-red-700' },
                'D': { mult: 0.00, sell: 0, buy: 0, label: 'Defaulted', color: 'text-gray-500' },
            },
            RATING_ORDER: ['IG', 'BB', 'B', 'CCC', 'CC', 'C', 'D'],
            MAX_ROUNDS: 10
        };

        // --- UTILITY FUNCTIONS ---

        const shuffle = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        };

        const getNextRating = (current) => {
            const index = GAME_CONSTANTS.RATING_ORDER.indexOf(current);
            return index > 0 ? GAME_CONSTANTS.RATING_ORDER[index - 1] : current;
        };

        const getPrevRating = (current, steps = 1) => {
            const index = GAME_CONSTANTS.RATING_ORDER.indexOf(current);
            const newIndex = Math.min(GAME_CONSTANTS.RATING_ORDER.length - 1, index + steps);
            return GAME_CONSTANTS.RATING_ORDER[newIndex];
        };

        const getRatingColor = (rating) => GAME_CONSTANTS.RATING_PRICES[rating]?.color || 'text-gray-400';
        const getRatingLabel = (rating) => GAME_CONSTANTS.RATING_PRICES[rating]?.label || 'Unknown';
        const getBuyPrice = (rating) => GAME_CONSTANTS.RATING_PRICES[rating]?.buy || 0;
        const getSellPrice = (rating) => GAME_CONSTANTS.RATING_PRICES[rating]?.sell || 0;
        
        const handleActionError = (promise) => {
            promise.catch(error => {
                const feedbackEl = document.getElementById('action-feedback');
                let message = error.message.replace('Error: ', '');
                if (message.includes('transaction failed')) {
                    message = 'Transaction Conflict: Please try action again.';
                }
                if (feedbackEl) {
                    feedbackEl.textContent = `ACTION FAILED: ${message}`;
                    feedbackEl.className = 'text-center p-2 mt-2 bg-red-100 text-red-700 rounded-lg font-bold transition-opacity duration-300';
                    setTimeout(() => { 
                        feedbackEl.textContent = ''; 
                        feedbackEl.className = ''; 
                    }, 5000);
                } else {
                     console.error("Unhandleable Action Error:", error);
                }
            });
        };
        window.handleActionError = handleActionError;

        // --- GAME DATA INITIALIZATION ---

        const createBondDeck = () => {
            let deck = [];
            const industries = ['Tech', 'Oil', 'Retail', 'Real Estate', 'Aviation', 'Pharma', 'Defense', 'Media', 'Auto', 'Energy'];
            const names = ['MegaCorp', 'Apex Holdings', 'Crimson Industries', 'Quantum Systems', 'Starlight LTD', 'Midnight Finance', 'Zephyr Dynamics'];
            let id = 1;
            ['T1', 'T2', 'T3'].forEach(tierKey => {
                const tier = GAME_CONSTANTS.TIERS[tierKey];
                for (let i = 0; i < 7; i++) {
                    const industry = industries[Math.floor(Math.random() * industries.length)];
                    const name = names[Math.floor(Math.random() * names.length)];
                    deck.push({
                        id: id++, name: `${name} (${tier.name} - ${industry})`, tier: tierKey, industry: industry,
                        yield: tier.yield, rating: tier.rating, faceValue: GAME_CONSTANTS.MAX_FACE_VALUE, ownerId: null,
                    });
                }
            });
            return shuffle(deck.slice(0, 20));
        };

        const createMarketDeck = () => {
            const events = [
                { type: 'BOOM', desc: 'Tech Sector Boom! All Tech bonds move up one rating. Max IG.', industry: 'Tech', effect: (game) => massRatingChange(game, 'Tech', getNextRating) },
                { type: 'BUST', desc: 'Oil Price Collapse. All Oil bonds move down one rating.', industry: 'Oil', effect: (game) => massRatingChange(game, 'Oil', getPrevRating) },
                { type: 'RATE_HIKE', desc: 'The Fed raises rates. All bonds move down one rating.', effect: (game) => massRatingChange(game, null, getPrevRating) },
                { type: 'LITIGATION', desc: 'Retail Lawsuits: All Retail bonds face a default roll (1-2 on D6).', industry: 'Retail', roll: true },
                { type: 'SUCCESS', desc: 'Economic Miracle! All bonds move up one rating. Max IG.', effect: (game) => massRatingChange(game, null, getNextRating) },
                { type: 'DEFAULT_TEST', desc: 'Energy Sector stress test. All Energy bonds roll for default (1-3 on D6).', industry: 'Energy', roll: true },
                { type: 'DEFAULT_TEST', desc: 'Auto Industry faces parts shortage. All Auto bonds roll for default (1-3 on D6).', industry: 'Auto', roll: true },
                { type: 'NO_EVENT', desc: 'Quiet Trading Day. Nothing major changes.' },
                { type: 'INDUSTRY_UP', desc: 'Pharma Sector breakthrough! All Pharma bonds move up two ratings. Max IG.', industry: 'Pharma', effect: (game) => massRatingChange(game, 'Pharma', (r) => getNextRating(getNextRating(r))) },
                { type: 'INDUSTRY_DOWN', desc: 'Aviation Regulation hits hard. All Aviation bonds move down two ratings.', industry: 'Aviation', effect: (game) => massRatingChange(game, 'Aviation', (r) => getPrevRating(getPrevRating(r))) },
            ];
            let deck = [];
            for(let i = 0; i < 4; i++) { deck = deck.concat(events); }
            return shuffle(deck.slice(0, 40));
        };

        const createMalfeasanceDeck = () => {
            return shuffle([
                { type: 'MALFEASANCE', desc: 'Whistleblower Scandal. Target bond drops three ratings.', downgrade: 3, tender: true },
                { type: 'MALFEASANCE', desc: 'Key Executive Quits. Target bond drops two ratings.', downgrade: 2, tender: true },
                { type: 'MALFEASANCE', desc: 'Insider Trading Fine. Target bond drops two ratings.', downgrade: 2, tender: true },
                { type: 'MALFEASANCE', desc: 'Regulatory Overreach. Target bond drops one rating.', downgrade: 1, tender: true },
                { type: 'BACKFIRE', desc: 'DUE DILIGENCE BACKFIRE. Colluders fined, Target compensated.', tender: true },
                { type: 'BACKFIRE', desc: 'DUE DILIGENCE BACKFIRE. Colluders fined, Target compensated.', tender: true },
                { type: 'SABOTAGE', desc: 'Public Relations Crisis. Target bond drops two ratings.', downgrade: 2, tender: false },
                { type: 'SABOTAGE', desc: 'Hostile Press Leak. Target bond drops two ratings.', downgrade: 2, tender: false },
                { type: 'SABOTAGE', desc: 'Targeted DDoS Attack. Target bond drops two ratings.', downgrade: 2, tender: false },
                { type: 'SABOTAGE', desc: 'Bad Quarterly Report. Target bond drops two ratings.', downgrade: 2, tender: false },
            ].slice(0, 10));
        };
        
        // --- FIREBASE INITIALIZATION AND GAME STATE MANAGEMENT ---
        
        const initFirebase = async () => {
            try {
                const firebaseConfig = {
                    apiKey: "AIzaSyCqMdhBWcXEfCw575HMHgsS2cRR64wBEBE",
                    authDomain: "junked-game.firebaseapp.com",
                    projectId: "junked-game",
                    storageBucket: "junked-game.firebasestorage.app",
                    messagingSenderId: "150414672185",
                    appId: "1:150414672185:web:5f48e37eacf96f0552e8e8"
                };
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                await signInAnonymously(auth);
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        gameId = GAME_SESSION_ID;
                        await ensurePlayerProfile(userId);
                        await initOrLoadGame(gameId);
                    }
                });
            } catch (error) {
                console.error("Firebase initialization error:", error);
                document.getElementById('game-log').innerHTML += `<p class="text-red-600">FATAL ERROR: ${error.message}</p>`;
            }
        };

        const ensurePlayerProfile = async (uid) => {
            const profileRef = doc(db, `artifacts/${APP_ID}/users/${uid}/junked_profile/data`);
            const profileSnap = await getDoc(profileRef);
            if (!profileSnap.exists()) {
                 await setDoc(profileRef, {
                    displayName: `Player ${Math.floor(Math.random() * 900) + 100}`,
                    userId: uid, joinedAt: new Date(),
                 });
            }
        };

        const initOrLoadGame = async (id) => {
            const gameRef = doc(db, DB_PATH(id));
            onSnapshot(gameRef, (doc) => {
                if (doc.exists()) { updateUI(doc.data()); }
            });
            try {
                await runTransaction(db, async (transaction) => {
                    const gameSnap = await transaction.get(gameRef);
                    if (!gameSnap.exists()) {
                        const bondDeck = createBondDeck();
                        const initialTrack = bondDeck.splice(0, 4);
                        const initialPlayers = {};
                        const playerName = `Player ${Math.floor(Math.random() * 900) + 100}`;
                        initialPlayers[userId] = {
                            cash: GAME_CONSTANTS.STARTING_CASH, tBills: 0, bonds: [],
                            insuranceContracts: 0, securedAssets: 0, actionsLeft: 0,
                            name: playerName, id: userId,
                        };
                        for(let i = 0; i < 3; i++) {
                            initialPlayers[userId].bonds.push({
                                id: `starter-${i + 1}-${userId}`, name: `Starter Bond ${i + 1}`, tier: 'T2',
                                industry: 'Mixed', yield: GAME_CONSTANTS.TIERS.T2.yield, rating: 'B',
                                faceValue: GAME_CONSTANTS.MAX_FACE_VALUE,
                            });
                        }
                        const initialState = {
                            round: 1, phase: 1, status: 'SETUP', currentPlayerIndex: 0, playerOrder: [userId],
                            players: initialPlayers, offeringsTrack: initialTrack, companyDeck: bondDeck,
                            marketDeck: createMarketDeck(), malfeasanceDeck: createMalfeasanceDeck(),
                            log: [{ time: new Date().toISOString(), message: `Game created by ${playerName}. Waiting for 3-4 players.` }],
                            currentMarketEvent: null, tenderOffer: null, 
                        };
                        transaction.set(gameRef, JSON.parse(JSON.stringify(initialState)));
                    } else {
                        const existingState = gameSnap.data();
                        if (!existingState.players[userId]) {
                            const playerName = `Player ${Math.floor(Math.random() * 900) + 100}`;
                            const newPlayerProfile = {
                                cash: GAME_CONSTANTS.STARTING_CASH, tBills: 0, bonds: [],
                                insuranceContracts: 0, securedAssets: 0, actionsLeft: 0,
                                name: playerName, primary: false, id: userId,
                            };
                            for(let i = 0; i < 3; i++) {
                                newPlayerProfile.bonds.push({
                                    id: `starter-${i + 1}-${userId}`, name: `Starter Bond ${i + 1}`, tier: 'T2',
                                    industry: 'Mixed', yield: GAME_CONSTANTS.TIERS.T2.yield, rating: 'B',
                                    faceValue: GAME_CONSTANTS.MAX_FACE_VALUE,
                                });
                            }
                            existingState.players[userId] = newPlayerProfile;
                            if(existingState.status === 'SETUP' && existingState.playerOrder.length < 4) {
                                existingState.playerOrder.push(userId);
                                transaction.update(gameRef, { 
                                    players: existingState.players, playerOrder: existingState.playerOrder,
                                    log: [...existingState.log, { time: new Date().toISOString(), message: `${playerName} joined the game.` }]
                                });
                            } else {
                                transaction.update(gameRef, { players: existingState.players });
                            }
                        }
                    }
                });
                const finalSnap = await getDoc(gameRef);
                if (finalSnap.exists()) { updateUI(finalSnap.data()); }
            } catch (e) {
                console.error("Transaction failed: ", e);
            }
        };

        const killGameForTesting = async () => {
            if (confirm("WARNING: Are you sure you want to completely DELETE the current game session? This cannot be undone.")) {
                const gameRef = doc(db, DB_PATH(gameId));
                try {
                    await deleteDoc(gameRef); 
                    window.location.reload(); 
                } catch (error) {
                    console.error("Failed to delete game session:", error);
                    alert("Error deleting game session.");
                }
            }
        };

        // --- GAME LOGIC FUNCTIONS ---

        const massRatingChange = (game, industry, changeFn, targetBonds = game.companyDeck.concat(Object.values(game.players).flatMap(p => p.bonds))) => {
            let log = [];
            const processBonds = (bonds, isPlayerBonds = false) => {
                bonds.forEach(bond => {
                    if (bond.rating === 'D') return;
                    if (!industry || bond.industry === industry || isPlayerBonds) {
                        const oldRating = bond.rating;
                        let newRating = changeFn(oldRating);
                        if ((changeFn === getNextRating || changeFn === ((r) => getNextRating(getNextRating(r)))) && oldRating === 'BB' && !isPlayerBonds) newRating = 'IG';
                        if (isPlayerBonds && changeFn === getNextRating && oldRating === 'BB') newRating = 'BB';
                        if(GAME_CONSTANTS.RATING_ORDER.indexOf(newRating) === -1) newRating = oldRating;
                        if (newRating !== oldRating) {
                            bond.rating = newRating;
                            log.push(`Rating change: ${bond.name} from ${oldRating} to ${newRating}.`);
                        }
                    }
                });
            };
            processBonds(game.offeringsTrack, false);
            processBonds(targetBonds, true);
            return log;
        };
        
        const performGameAction = async (actionType, payload = {}) => {
            const gameRef = doc(db, DB_PATH(gameId));
            return runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) throw new Error("Game not found.");
                let game = gameSnap.data();
                let player = game.players[userId];
                if (!player) throw new Error("You are not in this game session.");
                if (game.playerOrder[game.currentPlayerIndex] !== userId && !['JOIN', 'START_GAME'].includes(actionType)) {
                    throw new Error("It is not your turn.");
                }
                if (game.status === 'GAME_OVER') throw new Error("The game is over.");
                const isPhase3Action = ['BUY_BOND', 'SELL_BOND', 'DEPOSIT_WITHDRAW', 'RESEARCH', 'PURCHASE_INSURANCE', 'SABOTAGE', 'ASSET_MAINTENANCE', 'TENDER_INITIATE', 'END_TURN', 'SKIP_ACTION'].includes(actionType);
                if (isPhase3Action && game.phase !== 3) throw new Error("This action is only allowed in the Trading phase.");
                if (isPhase3Action && player.actionsLeft <= 0 && !['END_TURN', 'TENDER_RESOLVE'].includes(actionType)) throw new Error("No actions left.");
                
                let logMessage = '';

                switch(actionType) {
                    case 'JOIN':
                        if (game.playerOrder.length >= 4) throw new Error("Game is full.");
                        if (game.playerOrder.includes(userId)) throw new Error("Already joined.");
                        game.playerOrder.push(userId);
                        logMessage = `${game.players[userId].name} joined. Total players: ${game.playerOrder.length}.`;
                        break;
                    
                    case 'START_GAME':
                        if (game.playerOrder.length < 3) throw new Error("Need at least 3 players.");
                        if (game.status !== 'SETUP') throw new Error("Game already started.");
                        game.status = 'IN_PROGRESS';
                        game.phase = 1;
                        game.currentPlayerIndex = 0;
                        game.players[game.playerOrder[0]].actionsLeft = 2; // Pre-assign for phase 3
                        logMessage = 'Game started. Phase 1: Yield Collection.';
                        break;

                    case 'END_TURN':
                        player.actionsLeft = 0;
                        game.currentPlayerIndex = (game.currentPlayerIndex + 1) % game.playerOrder.length;
                        game.players[game.playerOrder[game.currentPlayerIndex]].actionsLeft = 2;
                        logMessage = `${player.name} ended their turn. It's now ${game.players[game.playerOrder[game.currentPlayerIndex]].name}'s turn.`;
                        if (game.currentPlayerIndex === 0) {
                            if (game.round === GAME_CONSTANTS.MAX_ROUNDS) {
                                game.status = 'GAME_OVER';
                                logMessage = `Round ${game.round} ended. GAME OVER.`;
                            } else {
                                game.round++;
                                game.phase = 1;
                                logMessage = `Starting Round ${game.round}. Phase 1: Yield Collection.`;
                            }
                        }
                        break;
                    
                    case 'NEXT_PHASE':
                        if (game.phase === 1) {
                            const yieldLog = performYieldCollection(game);
                            logMessage = yieldLog.join('; ') + `; Advancing to Phase 2: Market Shock.`;
                            game.phase = 2;
                        } else if (game.phase === 2) {
                            const shockLog = handleMarketShock(game);
                            logMessage = shockLog.join('; ') + `; Advancing to Phase 3: Trading Floor.`;
                            game.phase = 3;
                            game.currentPlayerIndex = 0;
                            Object.values(game.players).forEach(p => p.actionsLeft = 2);
                        }
                        break;

                    case 'SKIP_ACTION':
                        player.actionsLeft--;
                        logMessage = `${player.name} skipped an action.`;
                        break;

                    case 'BUY_BOND':
                        const bondIndex = game.offeringsTrack.findIndex(b => b.id == payload.bondId);
                        if (bondIndex === -1) throw new Error(`Bond not found.`);
                        const bond = game.offeringsTrack[bondIndex];
                        const price = getBuyPrice(bond.rating);
                        if (player.cash < price) throw new Error(`Insufficient funds.`);
                        player.cash -= price;
                        player.bonds.push(bond);
                        game.offeringsTrack.splice(bondIndex, 1);
                        if (game.companyDeck.length > 0) game.offeringsTrack.push(game.companyDeck.shift());
                        player.actionsLeft--;
                        logMessage = `${player.name} bought ${bond.name} for ${price}k.`;
                        break;

                    case 'SELL_BOND':
                        const sellBondIndex = player.bonds.findIndex(b => b.id === payload.bondId);
                        if (sellBondIndex === -1) throw new Error("Bond not in portfolio.");
                        const sellBond = player.bonds[sellBondIndex];
                        if (sellBond.rating === 'D') throw new Error("Cannot sell defaulted bond.");
                        player.cash += getSellPrice(sellBond.rating);
                        player.bonds.splice(sellBondIndex, 1);
                        player.actionsLeft--;
                        logMessage = `${player.name} sold ${sellBond.name}.`;
                        break;

                    case 'DEPOSIT_WITHDRAW':
                        const amount = parseInt(payload.amount);
                        if (isNaN(amount) || amount % 100 !== 0 || amount === 0) throw new Error("Amount must be a multiple of 100k.");
                        if (payload.type === 'DEPOSIT') {
                            if (player.cash < amount) throw new Error(`Insufficient cash.`);
                            player.cash -= amount; player.tBills += amount;
                            logMessage = `${player.name} deposited ${amount}k to T-Bills.`;
                        } else {
                            if (player.tBills < amount) throw new Error(`Insufficient T-Bills.`);
                            player.cash += amount; player.tBills -= amount;
                            logMessage = `${player.name} withdrew ${amount}k from T-Bills.`;
                        }
                        player.actionsLeft--;
                        break;

                    case 'RESEARCH':
                        if (player.cash < GAME_CONSTANTS.COST_RESEARCH) throw new Error("Insufficient funds for Research.");
                        player.cash -= GAME_CONSTANTS.COST_RESEARCH;
                        player.actionsLeft--;
                        logMessage = `${player.name} paid ${GAME_CONSTANTS.COST_RESEARCH}k for Market Research.`;
                        break;
                        
                    case 'PURCHASE_INSURANCE':
                        if (player.cash < GAME_CONSTANTS.COST_INSURANCE) throw new Error("Insufficient funds.");
                        player.cash -= GAME_CONSTANTS.COST_INSURANCE;
                        player.insuranceContracts++;
                        player.actionsLeft--;
                        logMessage = `${player.name} purchased Insurance for ${GAME_CONSTANTS.COST_INSURANCE}k.`;
                        break;

                    case 'ASSET_MAINTENANCE':
                        if (player.bonds.length === 0) throw new Error("No bonds to maintain.");
                        if (player.cash < GAME_CONSTANTS.COST_ASSET_MAINTENANCE) throw new Error("Insufficient funds.");
                        const maintainBondIndex = player.bonds.findIndex(b => b.id === payload.bondId);
                        if (maintainBondIndex === -1) throw new Error("Bond not found.");
                        const maintainBond = player.bonds[maintainBondIndex];
                        if (['IG', 'D', 'BB'].includes(maintainBond.rating)) throw new Error("Cannot maintain this bond.");
                        maintainBond.rating = getNextRating(maintainBond.rating);
                        player.actionsLeft--;
                        logMessage = `${player.name} upgraded ${maintainBond.name} to ${maintainBond.rating}.`;
                        break;
                        
                    case 'SABOTAGE':
                        if (player.cash < GAME_CONSTANTS.COST_SABOTAGE) throw new Error("Insufficient funds.");
                        const targetPlayer = game.players[payload.targetId];
                        const targetBondIndex = targetPlayer.bonds.findIndex(b => b.id === payload.bondId);
                        if (!targetPlayer || targetBondIndex === -1) throw new Error("Target not found.");
                        const sabotageCard = game.malfeasanceDeck.shift();
                        if (!sabotageCard || sabotageCard.type === 'BACKFIRE') {
                            if(sabotageCard) game.malfeasanceDeck.unshift(sabotageCard);
                            throw new Error("Sabotage attempt wasted on a Backfire card.");
                        }
                        const targetBond = targetPlayer.bonds[targetBondIndex];
                        const oldRating = targetBond.rating;
                        targetBond.rating = getPrevRating(oldRating, sabotageCard.downgrade || 2);
                        logMessage = `${player.name} sabotaged ${targetPlayer.name}'s ${targetBond.name}.`;
                        player.actionsLeft--;
                        break;

                    case 'TENDER_INITIATE':
                        if (game.round <= GAME_CONSTANTS.TARGET_RESTRICTION_ROUNDS) throw new Error(`Tenders restricted until Round 4.`);
                        if (game.tenderOffer) throw new Error("Tender Offer in progress.");
                        if (payload.targetId === userId) throw new Error("Cannot target yourself.");
                        if (player.cash < GAME_CONSTANTS.BRIBE_AMOUNT) throw new Error(`Need ${GAME_CONSTANTS.BRIBE_AMOUNT}k for bribe.`);
                        const silentPartnerCheck = game.players[payload.silentPartnerId];
                        if(silentPartnerCheck.cash < 500) throw new Error(`Silent Partner lacks solvency for fine risk.`);
                        game.tenderOffer = {
                            leadRaider: userId, silentPartner: payload.silentPartnerId,
                            targetBondId: payload.bondId, targetId: payload.targetId,
                        };
                        player.cash -= GAME_CONSTANTS.BRIBE_AMOUNT; 
                        logMessage = `${player.name} initiated a Hostile Tender.`;
                        player.actionsLeft--;
                        break;

                    case 'TENDER_RESOLVE':
                        if (!game.tenderOffer || game.tenderOffer.leadRaider !== userId) throw new Error("No active Tender Offer to resolve.");
                        const { silentPartner, targetId, targetBondId } = game.tenderOffer;
                        const targetPlayerRes = game.players[targetId];
                        const silentPartnerRes = game.players[silentPartner];
                        const malfeasanceCard = game.malfeasanceDeck.shift();
                        if (malfeasanceCard.type === 'BACKFIRE') {
                            player.cash -= 300; silentPartnerRes.cash -= 300; // RICO Fine
                            player.cash += 200; silentPartnerRes.cash -= 200; // Bribe Repayment
                            targetPlayerRes.cash += 150; // Compensation
                            logMessage = `Tender Offer Backfired! Raiders fined, Target compensated.`;
                        } else {
                            const bondIdx = targetPlayerRes.bonds.findIndex(b => b.id === targetBondId);
                            const tBond = targetPlayerRes.bonds[bondIdx];
                            tBond.rating = getPrevRating(tBond.rating, malfeasanceCard.downgrade || 2);
                            if (tBond.rating === 'D') {
                                targetPlayerRes.bonds.splice(bondIdx, 1);
                                player.securedAssets++;
                                player.cash += 150; // Liquidation Bonus
                                logMessage = `Tender Succeeded! ${tBond.name} defaulted, asset seized.`;
                            } else {
                                logMessage = `Tender Sabotage deployed, but ${tBond.name} survived.`;
                            }
                        }
                        game.tenderOffer = null;
                        game.players[targetId] = targetPlayerRes;
                        game.players[silentPartner] = silentPartnerRes;
                        break;
                }
                if (logMessage) game.log.unshift({ time: new Date().toISOString(), message: logMessage });
                game.players[userId] = player; 
                transaction.set(gameRef, game);
            });
        };
        
        const performYieldCollection = (game) => {
            const log = [];
            Object.values(game.players).forEach(p => {
                let yieldTotal = p.bonds.reduce((acc, b) => acc + (b.rating !== 'D' ? b.yield : 0), 0);
                yieldTotal += Math.floor(p.tBills * GAME_CONSTANTS.T_BILL_YIELD_RATE);
                p.cash += yieldTotal;
                log.push(`${p.name} collected ${yieldTotal}k yield.`);
            });
            return log;
        };

        const handleMarketShock = (game) => {
            const log = [];
            let card = game.marketDeck.shift();
            if (!card) {
                log.push('Market Deck empty! Reshuffling...');
                game.marketDeck = createMarketDeck();
                card = game.marketDeck.shift();
            }
            game.currentMarketEvent = card.desc;
            log.push(`Market Event: ${card.desc}`);
            if (card.effect) log.push(...card.effect(game));
            if (card.roll) {
                Object.values(game.players).forEach(p => {
                    p.bonds.filter(b => b.industry === card.industry).forEach(bond => {
                        if ((Math.floor(Math.random() * 6) + 1) <= 3) {
                            if (p.insuranceContracts > 0) {
                                p.insuranceContracts--;
                                log.push(`${p.name} used Insurance to save ${bond.name}!`);
                            } else {
                                bond.rating = 'D';
                                log.push(`${p.name}'s ${bond.name} defaulted!`);
                            }
                        } else {
                            log.push(`${p.name}'s ${bond.name} survived.`);
                        }
                    });
                });
            }
            return log;
        };
        
        const showResearchModal = () => {
            if (!currentGameState) return;
            const topThreeCards = currentGameState.marketDeck.slice(0, 3);
            const cardListEl = document.getElementById('research-card-list');
            cardListEl.innerHTML = topThreeCards.length ? 
                topThreeCards.map((card, i) => `<p class="text-sm p-2 bg-white rounded shadow-sm"><span class="font-bold">Card ${i + 1}:</span> ${card.desc}</p>`).join('') :
                `<p class="text-sm text-gray-500">The Market Deck is empty.</p>`;
            document.getElementById('research-modal').classList.remove('hidden');
        };

        // --- UI RENDERING ---

        const updateUI = (game) => {
            currentGameState = game;
            document.getElementById('current-round').textContent = game.round;
            document.getElementById('game-status').textContent = game.status;
            document.getElementById('game-phase').textContent = ['Yield Collection', 'Market Shock', 'Trading Floor'][game.phase - 1] || 'N/A';
            const currentPlayerId = game.playerOrder[game.currentPlayerIndex];
            const isCurrentPlayer = game.playerOrder.includes(userId) && currentPlayerId === userId;
            const myPlayer = game.players[userId];

            if (!myPlayer) {
                 document.getElementById('player-name').textContent = 'Connecting...';
                 document.getElementById('phase-control').innerHTML = '<p class="text-sm mt-2 text-yellow-600">Joining game...</p>';
                 return; 
            }
            
            ['player-name', 'player-cash', 'player-tbills', 'player-insurance', 'player-secured-assets', 'player-actions', 'current-player'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    switch(id) {
                        case 'player-name': el.textContent = myPlayer.name || '...'; break;
                        case 'player-cash': el.textContent = myPlayer.cash?.toLocaleString() || '0'; break;
                        case 'player-tbills': el.textContent = myPlayer.tBills?.toLocaleString() || '0'; break;
                        case 'player-insurance': el.textContent = myPlayer.insuranceContracts || '0'; break;
                        case 'player-secured-assets': el.textContent = myPlayer.securedAssets || '0'; break;
                        case 'player-actions': el.textContent = myPlayer.actionsLeft || '0'; break;
                        case 'current-player': el.textContent = game.players[currentPlayerId]?.name || '...'; break;
                    }
                }
            });
            
            document.getElementById('game-log').innerHTML = game.log.slice(0, 10).map(entry => 
                `<p class="text-xs text-gray-500">${new Date(entry.time).toLocaleTimeString()}</p><p class="text-sm">${entry.message}</p>`
            ).join('<hr class="my-1 border-gray-100">');

            const phaseControl = document.getElementById('phase-control');
            let phaseButtons = '';
            if (game.status === 'SETUP') {
                if (!game.playerOrder.includes(userId)) {
                    phaseButtons = `<button onclick="handleActionError(performGameAction('JOIN'))" class="bg-blue-600 text-white p-2 rounded-lg hover:bg-blue-700 w-full">Join Game</button>`;
                } else if (game.playerOrder.length < 3) {
                    phaseButtons = `<p class="text-sm mt-2 text-yellow-600 text-center">Waiting for ${3 - game.playerOrder.length} more player(s)...</p>`;
                } else {
                    phaseButtons = `<button onclick="handleActionError(performGameAction('START_GAME'))" class="bg-indigo-600 text-white p-2 rounded-lg hover:bg-indigo-700 w-full">Start Game</button>`;
                }
            } else if (isCurrentPlayer && game.phase < 3) {
                phaseButtons = `<button onclick="handleActionError(performGameAction('NEXT_PHASE'))" class="bg-indigo-600 text-white p-2 rounded-lg hover:bg-indigo-700 w-full">Advance to Phase ${game.phase + 1}</button>`;
                document.getElementById('current-market-event').textContent = game.currentMarketEvent || 'Waiting for Market Shock...';
            } else if (isCurrentPlayer && game.phase === 3) {
                 phaseButtons = `
                    <div class="grid grid-cols-2 gap-2">
                        <button onclick="handleActionError(performGameAction('SKIP_ACTION'))" class="bg-gray-400 text-white p-2 rounded-lg hover:bg-gray-500 disabled:opacity-50" ${myPlayer.actionsLeft <= 0 ? 'disabled' : ''}>Skip Action</button>
                        <button onclick="handleActionError(performGameAction('END_TURN'))" class="bg-orange-600 text-white p-2 rounded-lg hover:bg-orange-700">End Turn</button>
                    </div>`;
                 document.getElementById('current-market-event').textContent = 'Trading Floor is open.';
            } else {
                phaseButtons = `<p class="text-sm text-gray-600 text-center">Waiting for ${game.players[currentPlayerId]?.name} to act.</p>`;
                document.getElementById('current-market-event').textContent = game.currentMarketEvent || 'Market is stable.';
            }
            phaseControl.innerHTML = phaseButtons;
            
            renderTenders(game);
            renderOfferings(game);
            renderPortfolios(game);
            setupModals(game);
        };

        const renderTenders = (game) => {
             const tenderDiv = document.getElementById('tender-offer-status');
             tenderDiv.className = 'p-4 rounded-lg mt-4';
             if (game.tenderOffer) {
                 tenderDiv.classList.add('bg-red-100', 'border', 'border-red-400');
                 const { leadRaider, silentPartner, targetId } = game.tenderOffer;
                 tenderDiv.innerHTML = `
                    <p class="font-bold text-lg text-red-700">HOSTILE TENDER OFFER IN PROGRESS!</p>
                    <p class="text-sm text-gray-700">Raider: ${game.players[leadRaider]?.name} | Partner: ${game.players[silentPartner]?.name} | Target: ${game.players[targetId]?.name}</p>
                    ${leadRaider === userId && game.phase === 3 ? 
                        `<button onclick="handleActionError(performGameAction('TENDER_RESOLVE'))" class="mt-2 bg-red-700 text-white p-2 rounded-lg hover:bg-red-800">Resolve Tender</button>` :
                        `<p class="text-sm mt-1">Waiting for Raider to resolve.</p>`}
                 `;
             } else {
                 tenderDiv.classList.add('bg-gray-50', 'border', 'border-gray-200');
                 tenderDiv.innerHTML = `<p class="text-sm text-gray-500">No active Hostile Tender Offer.</p>`;
             }
        };

        const renderOfferings = (game) => {
            const isPlayerTurn = game.playerOrder[game.currentPlayerIndex] === userId;
            document.getElementById('offerings-track').innerHTML = game.offeringsTrack.map(bond => {
                const isDisabled = !isPlayerTurn || game.phase !== 3 || game.tenderOffer || game.players[userId].actionsLeft <= 0;
                return `
                    <div class="p-4 bg-white shadow-lg rounded-xl border ${bond.rating === 'D' ? 'border-red-700' : 'border-gray-200'}">
                        <p class="font-bold text-lg">${bond.name.split('(')[0].trim()}</p>
                        <p class="text-xs text-gray-500">${bond.name.split('(')[1]}</p><hr class="my-2">
                        <p class="text-sm">Yield: <span class="font-bold">${bond.yield}k</span></p>
                        <p class="text-sm">Rating: <span class="font-bold ${getRatingColor(bond.rating)}">${getRatingLabel(bond.rating)} (${bond.rating})</span></p>
                        <p class="text-lg mt-2 font-extrabold text-indigo-700">Buy: ${getBuyPrice(bond.rating)}k</p>
                        <button onclick="handleActionError(performGameAction('BUY_BOND', {bondId: ${bond.id}}))" 
                                class="mt-2 w-full bg-indigo-500 text-white p-1 rounded-lg hover:bg-indigo-600 disabled:opacity-50" ${isDisabled ? 'disabled' : ''}>
                                Buy
                        </button>
                    </div>
                `;
            }).join('');
        };

        const renderPortfolios = (game) => {
            document.getElementById('portfolios').innerHTML = `<div class="flex flex-wrap -m-2">${game.playerOrder.map(pId => {
                const player = game.players[pId];
                const isMine = pId === userId, isCurrent = game.playerOrder[game.currentPlayerIndex] === pId;
                const netWorth = player.cash + player.tBills + (player.securedAssets * 250) + player.bonds.reduce((acc, b) => acc + getSellPrice(b.rating), 0);
                return `
                    <div class="w-full lg:w-1/2 p-2">
                        <div class="rounded-xl p-4 shadow-2xl ${isCurrent ? 'border-4 border-indigo-500 bg-white' : 'border bg-gray-50'}">
                            <div class="flex justify-between items-center mb-3">
                                <h3 class="text-xl font-bold ${isCurrent ? 'text-indigo-700' : 'text-gray-800'}">${player.name}${isMine ? ' (You)' : ''}</h3>
                                <p class="text-lg font-extrabold text-green-700">NW: ${netWorth.toLocaleString()}k</p>
                            </div>
                            <p class="text-sm">Cash: ${player.cash.toLocaleString()}k | T-Bills: ${player.tBills.toLocaleString()}k | Ins: ${player.insuranceContracts} | Assets: ${player.securedAssets}</p>
                            <div class="mt-3 grid grid-cols-1 md:grid-cols-2 gap-2 max-h-48 overflow-y-auto p-1">
                                ${player.bonds.length ? player.bonds.map(bond => {
                                    const canAct = isCurrent && game.phase === 3 && !game.tenderOffer && player.actionsLeft > 0;
                                    return `
                                    <div class="p-2 bg-gray-100 rounded-lg shadow-inner ${bond.rating === 'D' ? 'opacity-60 line-through' : ''}">
                                        <p class="text-sm font-semibold">${bond.name.split('(')[0].trim()}</p>
                                        <p class="text-xs ${getRatingColor(bond.rating)}">Rating: ${bond.rating}</p>
                                        <p class="text-xs">Yield: ${bond.yield}k | Value: ${getSellPrice(bond.rating)}k</p>
                                        ${isMine && canAct ? `<button onclick="handleActionError(performGameAction('SELL_BOND', {bondId: '${bond.id}'}))" class="text-xs bg-red-400 text-white px-2 py-1 rounded-md hover:bg-red-500" ${bond.rating === 'D' ? 'disabled' : ''}>Sell</button>` : ''}
                                        ${!isMine && canAct && game.round > 3 ? `<button onclick="document.getElementById('tender-modal-target-bond').value='${bond.id}'; document.getElementById('tender-modal-target-id').value='${pId}'; document.getElementById('tender-modal-target-name').value='${player.name}'; setupModals(game); document.getElementById('tender-modal').classList.remove('hidden');" class="text-xs bg-red-800 text-white px-2 py-1 rounded-md hover:bg-red-900">Tender</button>` : ''}
                                    </div>`;
                                }).join('') : `<p class="text-xs text-gray-400 col-span-2">No bonds held.</p>`}
                            </div>
                        </div>
                    </div>`;
            }).join('')}</div>`;
        };

        const setupModals = (game) => {
            if (!game) return;
            const silentPartnerSelect = document.getElementById('tender-modal-silent-partner');
            if (silentPartnerSelect) {
                const targetId = document.getElementById('tender-modal-target-id').value;
                silentPartnerSelect.innerHTML = '<option value="" disabled selected>Select Partner</option>' + game.playerOrder
                    .filter(pId => pId !== userId && pId !== targetId)
                    .map(pId => {
                        const player = game.players[pId], solvent = player.cash >= 500;
                        return `<option value="${pId}" ${!solvent ? 'disabled' : ''}>${player.name} (${solvent ? 'Solvent' : `Insolvent`})</option>`;
                    }).join('');
            }
            const maintainBondSelect = document.getElementById('asset-maintenance-bond');
            if (maintainBondSelect) {
                maintainBondSelect.innerHTML = '<option value="" disabled selected>Select Bond</option>' + (game.players[userId]?.bonds || [])
                    .filter(b => !['IG', 'D', 'BB'].includes(b.rating))
                    .map(b => `<option value="${b.id}">${b.name} (${b.rating})</option>`).join('');
            }
            const tenderTargetDisplay = document.getElementById('tender-modal-target-name-display');
            if(tenderTargetDisplay) tenderTargetDisplay.textContent = document.getElementById('tender-modal-target-name').value;
        };

        window.performGameAction = performGameAction;
        window.setupModals = setupModals;
        window.killGameForTesting = killGameForTesting;
        window.showResearchModal = showResearchModal;
        window.onload = initFirebase;

        document.addEventListener('DOMContentLoaded', () => {
             document.getElementById('form-deposit-withdraw').addEventListener('submit', (e) => {
                 e.preventDefault();
                 const type = e.target.querySelector('select[name="type"]').value;
                 const amount = e.target.querySelector('input[name="amount"]').value;
                 handleActionError(performGameAction('DEPOSIT_WITHDRAW', { type, amount: parseInt(amount) }));
                 e.target.closest('.fixed').classList.add('hidden');
             });
             document.getElementById('form-asset-maintenance').addEventListener('submit', (e) => {
                 e.preventDefault();
                 const bondId = e.target.querySelector('#asset-maintenance-bond').value;
                 handleActionError(performGameAction('ASSET_MAINTENANCE', { bondId }));
                 e.target.closest('.fixed').classList.add('hidden');
             });
             document.getElementById('form-tender-initiate').addEventListener('submit', (e) => {
                 e.preventDefault();
                 const targetId = e.target.querySelector('#tender-modal-target-id').value;
                 const bondId = e.target.querySelector('#tender-modal-target-bond').value;
                 const silentPartnerId = e.target.querySelector('#tender-modal-silent-partner').value;
                 handleActionError(performGameAction('TENDER_INITIATE', { targetId, bondId, silentPartnerId }));
                 e.target.closest('.fixed').classList.add('hidden');
             });
        });
    </script>
</head>
<body class="bg-gray-100 font-inter p-4 lg:p-8">

    <header class="bg-white shadow-xl rounded-xl p-6 mb-6">
        <h1 class="text-3xl font-extrabold text-indigo-700">JUNKED: The Game of High-Stakes Yields</h1>
        <div class="mt-4 flex flex-wrap gap-x-6 gap-y-2 text-sm font-semibold">
            <p>Round: <span id="current-round" class="text-lg text-indigo-500">1</span>/<span id="max-rounds">10</span></p>
            <p>Status: <span id="game-status" class="text-lg text-indigo-500">SETUP</span></p>
            <p>Phase: <span id="game-phase" class="text-lg text-indigo-500">Waiting...</span></p>
            <p>Current Player: <span id="current-player" class="text-lg text-orange-500">N/A</span></p>
        </div>
    </header>

    <main class="grid grid-cols-1 lg:grid-cols-4 gap-6">
        <div class="lg:col-span-1 bg-white shadow-xl rounded-xl p-4 sticky top-8 h-fit">
            <h2 class="text-2xl font-bold text-gray-800 border-b pb-2 mb-3">Your Portfolio</h2>
            <div class="space-y-2 text-sm">
                <p class="text-lg font-extrabold" id="player-name">Loading...</p>
                <p class="font-bold text-green-700">Cash: <span id="player-cash">0</span>k</p>
                <p>T-Bills: <span id="player-tbills">0</span>k</p>
                <p>Insurance: <span id="player-insurance">0</span></p>
                <p>Secured Assets: <span id="player-secured-assets">0</span> (<span class="font-bold">250k</span>/ea)</p>
                <p class="text-lg font-bold text-orange-600 pt-2 border-t mt-3">Actions Left: <span id="player-actions">0</span></p>
            </div>
            <div id="action-feedback" class="mt-2 text-sm"></div>
            <div id="phase-control" class="mt-4"></div>
            <h3 class="text-lg font-bold mt-4 border-t pt-3">Trading Floor Actions</h3>
            <div class="grid grid-cols-2 gap-2 mt-2">
                <button onclick="document.getElementById('deposit-withdraw-modal').classList.remove('hidden')" class="bg-purple-500 text-white p-2 rounded-lg text-sm hover:bg-purple-600">T-Bills</button>
                <button onclick="handleActionError(performGameAction('RESEARCH').then(() => { if (currentGameState) showResearchModal(); }))" class="bg-gray-500 text-white p-2 rounded-lg text-sm hover:bg-gray-600" id="btn-research">Research (50k)</button>
                <button onclick="handleActionError(performGameAction('PURCHASE_INSURANCE'))" class="bg-blue-500 text-white p-2 rounded-lg text-sm hover:bg-blue-600">Insurance (75k)</button>
                <button onclick="document.getElementById('asset-maintenance-modal').classList.remove('hidden');" class="bg-green-500 text-white p-2 rounded-lg text-sm hover:bg-green-600" id="btn-asset-maintenance">Maintain (75k)</button>
                <button onclick="killGameForTesting()" class="col-span-2 bg-red-700 text-white p-2 rounded-lg hover:bg-red-800 text-sm mt-2">Nuclear Option (Reset DB)</button>
            </div>
        </div>

        <div class="lg:col-span-3">
            <div class="bg-yellow-100 p-4 rounded-xl shadow-inner mb-4">
                <p class="font-bold text-orange-700">Current Market Event:</p>
                <p id="current-market-event" class="text-lg text-orange-800">Awaiting market shock...</p>
            </div>
            <div id="tender-offer-status"></div>
            <h2 class="text-2xl font-bold text-gray-800 border-b pb-2 mb-3">Bond Offerings Track</h2>
            <div id="offerings-track" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6"></div>
            <h2 class="text-2xl font-bold text-gray-800 border-b pb-2 mb-3">Player Portfolios</h2>
            <div id="portfolios"></div>
        </div>
        
        <div class="lg:col-span-4 bg-white shadow-xl rounded-xl p-4 mt-6">
            <h2 class="text-xl font-bold text-gray-800 border-b pb-2 mb-3">Game Log</h2>
            <div id="game-log" class="text-gray-700 space-y-2 text-sm max-h-48 overflow-y-auto"></div>
        </div>
    </main>

    <!-- MODALS -->
    <div id="deposit-withdraw-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden flex items-center justify-center z-50">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm">
            <h3 class="text-xl font-bold mb-4">T-Bills</h3>
            <form id="form-deposit-withdraw">
                <div class="mb-4">
                    <label class="block text-sm font-bold mb-2">Action</label>
                    <select name="type" required class="shadow border rounded w-full py-2 px-3"><option value="DEPOSIT">Deposit</option><option value="WITHDRAW">Withdraw</option></select>
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-bold mb-2">Amount (multiple of 100k)</label>
                    <input name="amount" type="number" step="100" min="100" required placeholder="e.g., 500" class="shadow border rounded w-full py-2 px-3">
                </div>
                <div class="flex justify-between"><button type="button" onclick="this.closest('.fixed').classList.add('hidden')" class="bg-gray-400 text-white p-2 rounded-lg">Cancel</button><button type="submit" class="bg-purple-600 text-white p-2 rounded-lg">Confirm</button></div>
            </form>
        </div>
    </div>
    <div id="asset-maintenance-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden flex items-center justify-center z-50">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm">
            <h3 class="text-xl font-bold mb-4 text-green-600">Asset Maintenance (75k)</h3>
            <form id="form-asset-maintenance">
                <div class="mb-4">
                    <label class="block text-sm font-bold mb-2">Bond to Upgrade</label>
                    <select id="asset-maintenance-bond" name="bondId" required class="shadow border rounded w-full py-2 px-3"></select>
                </div>
                <p class="text-xs text-gray-500 mb-4">Upgrades a bond one step (max: BB).</p>
                <div class="flex justify-between"><button type="button" onclick="this.closest('.fixed').classList.add('hidden')" class="bg-gray-400 text-white p-2 rounded-lg">Cancel</button><button type="submit" class="bg-green-600 text-white p-2 rounded-lg">Apply</button></div>
            </form>
        </div>
    </div>
    <div id="tender-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden flex items-center justify-center z-50">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-lg">
            <h3 class="text-xl font-bold mb-4 text-red-800">Hostile Tender Offer (200k Bribe)</h3>
            <form id="form-tender-initiate">
                <input type="hidden" id="tender-modal-target-id"><input type="hidden" id="tender-modal-target-bond"><input type="hidden" id="tender-modal-target-name">
                <div class="space-y-4">
                    <p class="font-semibold">Targeting: <span id="tender-modal-target-name-display" class="font-bold"></span></p>
                    <div>
                        <label class="block text-sm font-bold mb-2">Silent Partner</label>
                        <select id="tender-modal-silent-partner" name="silentPartnerId" required class="shadow border rounded w-full py-2 px-3"></select>
                    </div>
                    <p class="text-xs text-red-500">WARNING: Partner must have 500k cash to cover potential fine and bribe repayment.</p>
                </div>
                <div class="flex justify-between mt-6"><button type="button" onclick="this.closest('.fixed').classList.add('hidden')" class="bg-gray-400 text-white p-2 rounded-lg">Cancel</button><button type="submit" class="bg-red-800 text-white p-2 rounded-lg">Initiate</button></div>
            </form>
        </div>
    </div>
    <div id="research-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden flex items-center justify-center z-50">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-md">
            <h3 class="text-xl font-bold mb-4 text-gray-800">Research Results</h3>
            <p class="text-sm mb-4">Top three cards of the Market Deck:</p>
            <div id="research-card-list" class="space-y-2 border p-3 rounded-lg bg-gray-50"></div>
            <div class="flex justify-end mt-6">
                <button type="button" onclick="document.getElementById('research-modal').classList.add('hidden')" class="bg-gray-600 text-white p-2 rounded-lg hover:bg-gray-700">Dismiss</button>
            </div>
        </div>
    </div>
</body>
</html>

